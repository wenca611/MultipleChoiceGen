# Základy programátora by Ing. Václav Pastušek - 2025
#
# Neručím za správnost
# Generated by ChatGPT


### inspirace: chrome-extension://efaidnbmnnnibpcajpcglclefindmkaj/https://pruvodce.ucw.cz/static/pruvodce.pdf

## Algoritmy
Které vlastnosti musí mít algoritmus, aby byl formálně správný?:0.9:3.0:0.1
Konečnost (finitnost):1
Determinovanost:1
Vstup a výstup:1
Efektivita:1
Nekonečný počet kroků, pokud je výpočetně složitý
-AI(RL) jsou vytvořeny z konečných kroků, což simuluje konečnost

Co znamená, že algoritmus je deterministický?
Každý krok je jednoznačně definovaný:1
Výsledek závisí na náhodě
Ze stejného vstupu vzniká vždy stejný výstup:1
Každý běh algoritmu může skončit jinak

Které tvrzení o algoritmu je pravdivé?:0.5:2.0:0.1
Algoritmus vždy končí (pokud je správně navržený):1
Algoritmus je obecný postup řešení problému:1
Algoritmus vždy obsahuje cyklus
Algoritmus lze provádět jen na počítači

Co může být vstupem algoritmu?:0.07500000000000001:0.0:0.1
Čísla nebo texty:1
Datové struktury:1
Může mít i nulový vstup:1
Pouze obrázky

Co z následujícího nejlépe vystihuje výstup algoritmu?:0.5:2.0:0.1
Výsledek výpočtu závislý na vstupu:1
Interní stav proměnných
Stav paměti při ukončení algoritmu
Hodnota, kterou algoritmus „vrátí“ po skončení:1

## Časová a prostorová složitost
Co popisuje časová složitost algoritmu?:0.5:2.0:0.1
Kolik operací musí algoritmus provést vzhledem k velikosti vstupu:1
Kolik paměti algoritmus spotřebuje během výpočtu
Jak se mění doba běhu algoritmu při růstu vstupu:1
Jak dlouho běží hardware při provádění algoritmu

Které z následujících asymptotických notací se používají pro vyjádření časové složitosti?:0.2:1.0:0.1
O(n):1
Ω(n):1
Θ(n):1
π(n)

Co znamená notace O(n²)?:0.2:1.0:0.1
Čas roste úměrně druhé mocnině velikosti vstupu:1
Čas je konstantní bez ohledu na velikost vstupu
Algoritmus má nejlepší možný časový výkon
Algoritmus má kvadratickou časovou složitost:1

Proč je důležitá prostorová složitost algoritmu?:0.07500000000000001:0.0:0.1
Omezená paměť může omezit použitelnost algoritmu:1
Optimalizace paměti může zvýšit výkonnost:1
Použití více paměti vždy zrychlí algoritmus
Prostorová složitost se neřeší, pokud máme SSD disk

Který algoritmus má typicky prostorovou složitost O(1)?:0.275:1.0:0.1
Iterativní vyhledávání ve statickém poli:1
Merge sort (rekurzivní implementace)
BFS pomocí fronty
Najít maximum v poli pomocí jednoho průchodu:1

Co znamená „nejhorší případ“ u časové složitosti?:0.2:1.0:0.1
Situace, kdy algoritmus potřebuje nejvíce kroků:1
Když program spadne
Analýza prováděná na vstupu, který způsobí maximální dobu běhu:1
Stav, kdy algoritmus vrací nesprávný výsledek

Co značí notace O(n) v časové složitosti?:0.9:3.0:0.1
Horní mez počtu operací vzhledem k velikosti vstupu:1
Nejhorší čas potřebný k zápisu do souboru
Minimální garantovaný čas běhu
Kolik operací může algoritmus maximálně vykonat:1

Kdy použijeme Θ(n)?:0.6500000000000001:2.0:0.1
Když chceme přesně popsat růst složitosti v nejlepším i nejhorším případě:1
Když algoritmus používá náhodu
Když složitost není určena
Pokud algoritmus běží stejně dlouho v různých případech:1

Jaký význam má notace Ω(n)?:0.5:2.0:0.1
Vyjadřuje dolní mez složitosti:1
Ukazuje nejlepší možný čas algoritmu:1
Znamená, že algoritmus nikdy nevyužije víc než n kroků
Vyjadřuje výstupní hodnotu

Proč je Big-O nejpoužívanější notací?:-0.025:-1.0:0.1
Popisuje nejhorší případ, který je důležitý pro odhad výkonnosti:1
Je jednodušší než ostatní notace
Umožňuje srovnávat algoritmy podle efektivity:1
Popisuje pouze časovou složitost, ne prostorovou

## ROM a RAM
Která paměť je zapisovatelná za běhu?:0.5:2.0:0.1
RAM:1
ROM

Která paměť uchovává data i po vypnutí?:0.5:2.0:0.1
RAM
ROM:1

Co je typickým použitím ROM?:0.2:1.0:0.1
Uložení firmware:1
Spuštění aplikací v systému

Co platí o RAM?:-0.03333333333333334:-1.0:0.1
Je rychlá a dočasná:1
Je trvalá a neměnná
Slouží k běhu programů:1

# Třídící algoritmy
Který z následujících algoritmů má v nejhorším případě časovou složitost O(n²)?
Bubble Sort:1
Insertion Sort:1
Selection Sort:1
Merge Sort

Který třídicí algoritmus je typicky nejrychlejší pro velké množství náhodných dat?
Quick Sort:1
Bubble Sort
Counting Sort (bez znalosti rozsahu hodnot)
Selection Sort
- má O(n²), ale vhodným výběrem pivota překoná v praxi ostatní známe algoritmy

Které z následujících třídicích algoritmů mají v nejhorším případě maximálně O(n log n)?
Merge Sort:1
Heap Sort:1
Insertion Sort
Quick Sort (bez optimalizace pivotu)

# TODO
# Datové struktury (obecně)
# OOP
# Prohledávací algoritmy
# Strojové učení
# Zpětnovazební učení
# Python
# Java
# C#
# SQL (Postgress/MSQL)
# JavaScript